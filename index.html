<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>斯大林格勒：战术指挥官（p5.js）</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
  <style>
    :root {
      color-scheme: dark;
      --bg: #070b15;
      --panel: #111a2b;
      --panel2: #0d1423;
      --line: #25344f;
      --text: #e6edf9;
      --sub: #9fb2d6;
      --axis: #e8c66a;
      --sov: #e46a6a;
      --ok: #56d364;
      --warn: #ffb86b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(circle at 20% 0%, #0f1d36, var(--bg) 45%);
      font-family: "Noto Sans SC", "Microsoft YaHei", system-ui, sans-serif;
      color: var(--text);
      overflow: hidden;
    }
    #ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: grid;
      grid-template-columns: min(350px, 32vw) 1fr min(350px, 30vw);
      grid-template-rows: 1fr auto;
      gap: 10px;
      padding: 10px;
    }
    .panel {
      pointer-events: auto;
      background: linear-gradient(160deg, rgba(18, 28, 45, .9), rgba(10, 14, 22, .92));
      border: 1px solid var(--line);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
      overflow: hidden;
    }
    #leftPanel, #rightPanel { padding: 12px; overflow: auto; }
    #rightPanel { grid-column: 3; }
    #bottomBar {
      grid-column: 1 / span 3;
      display: grid;
      grid-template-columns: repeat(8, minmax(80px, 1fr));
      gap: 8px;
      padding: 10px;
    }
    .btn {
      border: 1px solid #38507c;
      background: linear-gradient(180deg, #223862, #172845);
      color: var(--text);
      border-radius: 10px;
      padding: 8px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      pointer-events: auto;
      transition: .16s;
    }
    .btn:hover { filter: brightness(1.1); }
    .btn.active { outline: 2px solid #6ca7ff; }
    .btn.warn { background: linear-gradient(180deg, #5a2f2f, #441f1f); border-color: #8f3f3f; }
    h2 { margin: 0 0 8px; font-size: 18px; }
    .muted { color: var(--sub); font-size: 13px; }
    .stat {
      display: flex; justify-content: space-between; align-items: center;
      border-bottom: 1px dashed rgba(255,255,255,.12);
      padding: 6px 0;
      font-size: 13px;
    }
    .log { max-height: 240px; overflow: auto; font-size: 12px; line-height: 1.45; }
    .log div { border-left: 2px solid #304a73; padding-left: 8px; margin: 6px 0; color: #c8d6f2; }
    .titleSide-GER { color: var(--axis); }
    .titleSide-SOV { color: var(--sov); }
    .tag { padding: 2px 8px; border-radius: 999px; font-size: 12px; background: #1d2d49; border: 1px solid #31507d; }
    #startOverlay {
      position: fixed; inset: 0;
      background: rgba(4, 7, 12, .84);
      display: flex; align-items: center; justify-content: center;
      z-index: 10;
    }
    .card {
      width: min(92vw, 560px);
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 18px;
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; margin: 10px 0; }
    select {
      padding: 8px; border-radius: 8px; background: #111c30; border: 1px solid #2d4468; color: var(--text);
    }
    @media (max-width: 980px) {
      #ui { grid-template-columns: 1fr; grid-template-rows: auto auto auto; }
      #rightPanel { grid-column: 1; }
      #bottomBar { grid-template-columns: repeat(4, minmax(70px, 1fr)); }
    }
  </style>
</head>
<body>
  <div id="startOverlay">
    <div class="card">
      <h2>斯大林格勒：战术指挥官</h2>
      <p class="muted">升级版玩法：目标点控制、补给、ZOC、战斗士气、AI 回合、胜负判定。你将指挥营级战斗群进行多回合会战。</p>
      <div class="row">
        <label>玩家阵营
          <select id="pickSide"><option value="GER">德军（先手）</option><option value="SOV">苏军</option></select>
        </label>
        <label>AI 难度
          <select id="pickDiff"><option value="normal">正常</option><option value="hard">困难</option></select>
        </label>
      </div>
      <button id="startBtn" class="btn">开始战役</button>
    </div>
  </div>

  <div id="ui">
    <aside id="leftPanel" class="panel"></aside>
    <aside id="rightPanel" class="panel"></aside>
    <footer id="bottomBar" class="panel">
      <button class="btn active" data-mode="MOVE">移动</button>
      <button class="btn" data-mode="ATTACK">攻击</button>
      <button class="btn" data-mode="BOMBARD">炮击</button>
      <button class="btn" data-mode="FORTIFY">构筑</button>
      <button class="btn" id="btnSupply">补给</button>
      <button class="btn" id="btnCenter">定位单位</button>
      <button class="btn warn" id="btnEnd">结束回合</button>
      <button class="btn" id="btnRestart">重开</button>
    </footer>
  </div>

<script>
let W, H;
let hexSize = 30;
let originX = 30, originY = 40;
const COLS = 14, ROWS = 10;

const TERRAIN = {
  STEPPE: { name:'草原', cost:1, def:0, color:[65,90,74] },
  CITY: { name:'城区', cost:2, def:2, color:[96,96,105] },
  INDUSTRY: { name:'工业区', cost:2, def:3, color:[114,92,84] },
  HILL: { name:'高地', cost:2, def:1, color:[92,110,86] },
  RAIL: { name:'铁路', cost:1, def:0, color:[120,120,126] },
  RIVER: { name:'伏尔加河', cost:99, def:0, color:[48,78,140] },
  BRIDGE: { name:'桥梁', cost:1, def:0, color:[155,128,77] },
  EAST: { name:'东岸', cost:1, def:0, color:[72,85,82] }
};

let objectives = [
  { id:'KURGAN', q:4, r:4, vp:2, name:'马马耶夫岗', owner:null },
  { id:'STATION', q:3, r:3, vp:2, name:'火车站', owner:null },
  { id:'REDOCT', q:5, r:5, vp:3, name:'红十月工厂', owner:null },
  { id:'LANDING', q:8, r:4, vp:2, name:'中央渡口', owner:null },
  { id:'ELEVATOR', q:2, r:7, vp:2, name:'粮仓', owner:null }
];

const mapData = new Map();
const units = [];
let selected = null;
let mode = 'MOVE';
let logs = [];
let gameOver = false;

let state = {
  turn: 1,
  active: 'GER',
  playerSide: 'GER',
  aiSide: 'SOV',
  difficulty: 'normal',
  maxTurn: 14,
  vp: { GER:0, SOV:0 },
  support: { GER:{arty:1, air:1, supply:1}, SOV:{arty:1, air:0, supply:1} }
};

function setup() {
  W = windowWidth;
  H = windowHeight;
  createCanvas(W, H);
  angleMode(RADIANS);
  textFont('monospace');
  initMap();
  bindUI();
}

function windowResized() {
  W = windowWidth; H = windowHeight;
  resizeCanvas(W, H);
  hexSize = floor(constrain(W / 34, 20, 36));
}

function startGame() {
  const side = document.getElementById('pickSide').value;
  const diff = document.getElementById('pickDiff').value;
  state.playerSide = side;
  state.aiSide = side === 'GER' ? 'SOV' : 'GER';
  state.difficulty = diff;
  resetGame();
  document.getElementById('startOverlay').style.display = 'none';
}

function resetGame() {
  units.length = 0;
  selected = null;
  mode = 'MOVE';
  logs = [];
  gameOver = false;
  state.turn = 1;
  state.active = 'GER';
  state.vp = { GER:0, SOV:0 };
  state.support = { GER:{arty:1, air:1, supply:1}, SOV:{arty:1, air:0, supply:1} };
  objectives.forEach(o => o.owner = null);

  addUnit({ side:'GER', name:'71步兵师 / I营', q:0, r:3, atk:7, def:6, mp:5, hp:6, morale:7, army:'6集团军' });
  addUnit({ side:'GER', name:'24装甲师 / 战斗群', q:1, r:5, atk:9, def:6, mp:6, hp:5, morale:7, armor:1, army:'6集团军' });
  addUnit({ side:'GER', name:'100猎兵师 / I营', q:0, r:7, atk:7, def:7, mp:5, hp:6, morale:8, army:'6集团军' });

  addUnit({ side:'SOV', name:'62集团军 / NKVD营', q:7, r:4, atk:7, def:8, mp:5, hp:6, morale:8, army:'62集团军' });
  addUnit({ side:'SOV', name:'13近卫师 / II营', q:12, r:3, atk:8, def:7, mp:5, hp:6, morale:8, army:'62集团军' });
  addUnit({ side:'SOV', name:'海军步兵营', q:12, r:6, atk:8, def:6, mp:5, hp:5, morale:7, army:'62集团军' });

  refreshSide();
  log('战役开始：占领目标点并坚持到终局。');
}

function initMap() {
  mapData.clear();
  for (let r = 0; r < ROWS; r++) {
    for (let q = 0; q < COLS; q++) {
      let t = TERRAIN.STEPPE;
      if (q >= 9) t = TERRAIN.RIVER;
      if (q >= 11) t = TERRAIN.EAST;
      if ((q === 9 && r === 3) || (q === 9 && r === 6)) t = TERRAIN.BRIDGE;
      if (q >= 2 && q <= 8 && r >= 2 && r <= 8) t = TERRAIN.CITY;
      if ((q === 5 && r === 5) || (q === 5 && r === 6) || (q === 6 && r === 5)) t = TERRAIN.INDUSTRY;
      if ((r === 3 && q >= 1 && q <= 8) || (r === 4 && q >= 2 && q <= 8)) if (t !== TERRAIN.RIVER && t !== TERRAIN.EAST) t = TERRAIN.RAIL;
      if (q === 4 && r === 4) t = TERRAIN.HILL;
      mapData.set(hexKey(q, r), { q, r, terrain: t });
    }
  }
}

function addUnit(u) {
  units.push({ ...u, id: `${u.side}_${Math.random().toString(36).slice(2,9)}`, mpLeft:u.mp, acted:false, supplied:true, entrenched:0, ammo:2, alive:true });
}

function draw() {
  clear();
  background(10, 14, 24);
  drawHexes();
  drawObjectiveOverlay();
  drawUnits();
  drawSelectionOverlay();
  updatePanels();

  if (!gameOver && state.active === state.aiSide) {
    runAI();
  }
}

function drawHexes() {
  for (let r = 0; r < ROWS; r++) {
    for (let q = 0; q < COLS; q++) {
      const c = mapData.get(hexKey(q, r));
      if (!c) continue;
      const p = hexToPixel(q, r);
      stroke(30, 40, 60);
      strokeWeight(1.4);
      fill(...c.terrain.color);
      hexShape(p.x, p.y);
      fill(0, 80);
      noStroke();
      textSize(10);
      text(c.terrain.name[0], p.x - 4, p.y + 4);
    }
  }
}

function drawObjectiveOverlay() {
  objectives.forEach(o => {
    const p = hexToPixel(o.q, o.r);
    noFill();
    stroke(o.owner === 'GER' ? '#e8c66a' : o.owner === 'SOV' ? '#e46a6a' : '#b8c5de');
    strokeWeight(2);
    circle(p.x, p.y, hexSize * 1.2);
    noStroke();
    fill(245);
    textSize(10);
    textAlign(CENTER, CENTER);
    text(`${o.vp}`, p.x, p.y);
  });
  textAlign(LEFT, BASELINE);
}

function drawUnits() {
  units.filter(u => u.alive).forEach(u => {
    const p = hexToPixel(u.q, u.r);
    const base = u.side === 'GER' ? color(224, 193, 106) : color(208, 99, 99);
    fill(red(base), green(base), blue(base), u.side === state.active ? 255 : 180);
    stroke(0, 140);
    rectMode(CENTER);
    rect(p.x, p.y, hexSize * 1.6, hexSize * 0.9, 6);

    if (selected && selected.id === u.id) {
      noFill(); stroke('#d5e7ff'); strokeWeight(2);
      rect(p.x, p.y, hexSize * 1.8, hexSize * 1.1, 8);
    }

    noStroke(); fill(15);
    textSize(10);
    textAlign(CENTER, CENTER);
    text(`${u.hp}HP/${u.mpLeft}MP`, p.x, p.y + 1);
    if (u.entrenched) {
      fill('#c7e4ff');
      text(`E${u.entrenched}`, p.x + hexSize * 0.45, p.y - hexSize * 0.35);
    }
  });
  rectMode(CORNER);
  textAlign(LEFT, BASELINE);
}

function drawSelectionOverlay() {
  if (!selected || gameOver) return;
  if (mode === 'MOVE' && selected.side === state.active) {
    reachable(selected).forEach(t => {
      const p = hexToPixel(t.q, t.r);
      noFill(); stroke(190, 220, 255, 120); strokeWeight(1.8);
      hexShape(p.x, p.y);
      noStroke(); fill(230,230,240,120); textSize(9); textAlign(CENTER, CENTER);
      text(t.mp, p.x, p.y);
    });
  }
  if (mode === 'ATTACK' && selected.side === state.active) {
    enemiesAdjacent(selected).forEach(e => {
      const p = hexToPixel(e.q, e.r);
      noFill(); stroke(255, 120, 120, 160); strokeWeight(2); hexShape(p.x, p.y);
    });
  }
  textAlign(LEFT, BASELINE);
}

function mousePressed() {
  if (gameOver || mouseY > H - 100) return;
  const h = pixelToHex(mouseX, mouseY);
  if (!inMap(h.q, h.r)) return;
  const targetUnit = unitAt(h.q, h.r);

  if (targetUnit) {
    if (targetUnit.side === state.active) { selected = targetUnit; return; }
    if (selected && mode === 'ATTACK') doAttack(selected, targetUnit);
    if (selected && mode === 'BOMBARD') doBombard(targetUnit);
    return;
  }

  if (selected && mode === 'MOVE') doMove(selected, h.q, h.r);
}

function doMove(u, q, r) {
  if (u.side !== state.active || u.acted) return log('该单位本回合已行动。');
  const tile = reachable(u).find(t => t.q === q && t.r === r);
  if (!tile) return log('无法到达该格。');
  u.q = q; u.r = r; u.mpLeft = tile.mp;
  if (enemyZOC(q, r, opposite(u.side))) u.mpLeft = max(0, u.mpLeft - 1);
  log(`${u.name} 机动至 (${q},${r})。`);
  updateObjectives();
}

function doAttack(a, d) {
  if (a.side !== state.active || a.acted) return log('该单位无法继续攻击。');
  if (hexDist(a.q, a.r, d.q, d.r) !== 1) return log('必须邻接攻击。');
  const cell = mapData.get(hexKey(d.q, d.r));
  const defBonus = cell.terrain.def + d.entrenched;
  let atk = a.atk + floor(a.morale / 3) + (a.ammo > 0 ? 1 : 0);
  let def = d.def + defBonus + floor(d.morale / 3);
  if (!a.supplied) atk -= 2;
  const roll = floor(random(1, 7));
  const damage = max(0, floor((atk + roll - def) / 2));
  const counter = max(0, floor((def + 3 - atk) / 4));
  d.hp -= damage;
  a.hp -= counter;
  a.ammo = max(0, a.ammo - 1);
  a.acted = true;

  if (damage > 0) d.morale = max(3, d.morale - 1);
  if (counter > 0) a.morale = max(3, a.morale - 1);
  cleanupDead();
  log(`${a.name} 攻击 ${d.name}：造成 ${damage}，反损 ${counter}（d6=${roll}）`);
  updateObjectives();
  checkGameEnd();
}

function doBombard(target) {
  const s = state.support[state.active];
  if (s.arty <= 0 && s.air <= 0) return log('无炮火/空袭支援。');
  const useAir = s.air > 0 && state.active === 'GER';
  if (useAir) s.air--; else s.arty--;
  const cover = mapData.get(hexKey(target.q, target.r)).terrain.def;
  const roll = floor(random(1, 7));
  const hit = roll + (useAir ? 1 : 0) - cover >= 4;
  if (hit) {
    target.hp -= 1;
    target.morale = max(3, target.morale - 1);
    log(`${useAir ? '空袭' : '炮击'}命中 ${target.name}。`);
  } else {
    log(`${useAir ? '空袭' : '炮击'}偏离目标。`);
  }
  cleanupDead();
  checkGameEnd();
}

function doFortify() {
  if (!selected || selected.side !== state.active) return log('请选择己方单位。');
  if (selected.acted) return log('该单位已行动。');
  selected.entrenched = min(2, selected.entrenched + 1);
  selected.acted = true;
  log(`${selected.name} 构筑工事，工事等级 E${selected.entrenched}。`);
}

function doSupply() {
  const s = state.support[state.active];
  if (s.supply <= 0) return log('补给行动次数不足。');
  if (!selected || selected.side !== state.active) return log('请选择己方单位进行补给。');
  s.supply--;
  selected.supplied = true;
  selected.ammo = min(2, selected.ammo + 1);
  selected.morale = min(9, selected.morale + 1);
  log(`${selected.name} 完成补给，弹药与士气恢复。`);
}

function endTurn() {
  if (gameOver) return;
  updateObjectives();
  if (state.active === 'SOV') state.turn++;
  state.active = opposite(state.active);
  refreshSide();
  selected = null;
  checkGameEnd();
}

function refreshSide() {
  const t = state.turn;
  units.forEach(u => {
    if (!u.alive || u.side !== state.active) return;
    u.mpLeft = u.mp - (state.active === 'GER' && t % 2 === 0 ? 1 : 0);
    u.acted = false;
    u.supplied = supplyConnected(u);
    if (!u.supplied) u.morale = max(3, u.morale - 1);
  });
  state.support[state.active] = {
    arty: state.active === 'SOV' ? (t < 5 ? 1 : 2) : 1,
    air: state.active === 'GER' && t % 2 === 1 ? 1 : 0,
    supply: 1
  };
  log(`--- ${state.active} 第 ${state.turn} 回合 ---`);
}

function runAI() {
  if (frameCount % 22 !== 0) return;
  const aiUnits = units.filter(u => u.alive && u.side === state.aiSide);
  for (const u of aiUnits) {
    if (u.acted) continue;
    const adj = enemiesAdjacent(u);
    if (adj.length) { doAttack(u, weakest(adj)); return; }
    const obj = nearestUnfriendlyObjective(u.side, u.q, u.r);
    if (obj) {
      const options = reachable(u).filter(t => !unitAt(t.q, t.r));
      options.sort((a, b) => hexDist(a.q, a.r, obj.q, obj.r) - hexDist(b.q, b.r, obj.q, obj.r));
      if (options[0]) { doMove(u, options[0].q, options[0].r); if (state.difficulty === 'hard') u.entrenched = min(1, u.entrenched + 1); return; }
    }
    u.acted = true;
  }
  endTurn();
}

function updateObjectives() {
  objectives.forEach(o => {
    const g = units.find(u => u.alive && u.side === 'GER' && u.q === o.q && u.r === o.r);
    const s = units.find(u => u.alive && u.side === 'SOV' && u.q === o.q && u.r === o.r);
    if (g && !s) o.owner = 'GER';
    if (s && !g) o.owner = 'SOV';
  });
  state.vp = { GER:0, SOV:0 };
  objectives.forEach(o => { if (o.owner) state.vp[o.owner] += o.vp; });
}

function checkGameEnd() {
  const gerAlive = units.some(u => u.alive && u.side === 'GER');
  const sovAlive = units.some(u => u.alive && u.side === 'SOV');
  if (!gerAlive || !sovAlive || state.turn > state.maxTurn) {
    gameOver = true;
    const scoreGER = state.vp.GER + units.filter(u => u.alive && u.side === 'GER').length;
    const scoreSOV = state.vp.SOV + units.filter(u => u.alive && u.side === 'SOV').length;
    const result = scoreGER === scoreSOV ? '平局' : scoreGER > scoreSOV ? '德军胜' : '苏军胜';
    log(`战役结束：${result}（GER ${scoreGER} : SOV ${scoreSOV}）`);
  }
}

function cleanupDead() {
  units.forEach(u => {
    if (u.alive && u.hp <= 0) {
      u.alive = false;
      if (selected && selected.id === u.id) selected = null;
      log(`${u.name} 被击溃。`);
    }
  });
}

function bindUI() {
  document.getElementById('startBtn').addEventListener('click', startGame);
  document.querySelectorAll('[data-mode]').forEach(btn => {
    btn.addEventListener('click', () => {
      mode = btn.dataset.mode;
      document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      if (mode === 'FORTIFY') doFortify();
    });
  });
  document.getElementById('btnSupply').addEventListener('click', doSupply);
  document.getElementById('btnCenter').addEventListener('click', () => {
    const pick = units.find(u => u.alive && u.side === state.active);
    if (pick) selected = pick;
  });
  document.getElementById('btnEnd').addEventListener('click', endTurn);
  document.getElementById('btnRestart').addEventListener('click', () => {
    document.getElementById('startOverlay').style.display = 'flex';
  });
}

function updatePanels() {
  const left = document.getElementById('leftPanel');
  const right = document.getElementById('rightPanel');
  const activeTitleClass = `titleSide-${state.active}`;

  left.innerHTML = `
    <h2 class="${activeTitleClass}">第 ${state.turn} 回合 · ${state.active === 'GER' ? '德军行动' : '苏军行动'}</h2>
    <div class="stat"><span>模式</span><span class="tag">${mode}</span></div>
    <div class="stat"><span>胜利点</span><span>GER ${state.vp.GER} : ${state.vp.SOV} SOV</span></div>
    <div class="stat"><span>回合上限</span><span>${state.maxTurn}</span></div>
    <div class="stat"><span>当前支援</span><span>空袭 ${state.support[state.active].air} / 炮击 ${state.support[state.active].arty}</span></div>
    <div class="stat"><span>补给动作</span><span>${state.support[state.active].supply}</span></div>
    <div class="stat"><span>玩家阵营</span><span>${state.playerSide}</span></div>
    <p class="muted">规则要点：进入敌军 ZOC 会额外消耗 MP；无补给会持续降士气；目标点每回合实时计分。</p>
    <h3>目标点控制</h3>
    ${objectives.map(o => `<div class="stat"><span>${o.name} (+${o.vp})</span><span>${o.owner || '中立'}</span></div>`).join('')}
  `;

  if (!selected) {
    right.innerHTML = `<h2>单位详情</h2><p class="muted">点击地图单位以查看详情。</p><h3>战报</h3><div class="log">${logs.slice(-10).map(l => `<div>${l}</div>`).join('')}</div>`;
    return;
  }
  const t = mapData.get(hexKey(selected.q, selected.r));
  right.innerHTML = `
    <h2>${selected.name}</h2>
    <div class="stat"><span>阵营 / 集团军</span><span>${selected.side} · ${selected.army}</span></div>
    <div class="stat"><span>HP / 士气</span><span>${selected.hp} / ${selected.morale}</span></div>
    <div class="stat"><span>ATK / DEF</span><span>${selected.atk} / ${selected.def}</span></div>
    <div class="stat"><span>MP</span><span>${selected.mpLeft}/${selected.mp}</span></div>
    <div class="stat"><span>补给 / 弹药</span><span>${selected.supplied ? '正常' : '中断'} / ${selected.ammo}</span></div>
    <div class="stat"><span>工事</span><span>E${selected.entrenched}</span></div>
    <div class="stat"><span>地形</span><span>${t.terrain.name} DEF+${t.terrain.def}</span></div>
    <div class="stat"><span>坐标</span><span>(${selected.q}, ${selected.r})</span></div>
    <h3>战报</h3><div class="log">${logs.slice(-10).map(l => `<div>${l}</div>`).join('')}</div>
  `;
}

function reachable(u) {
  const best = new Map([[hexKey(u.q,u.r), u.mpLeft]]);
  const queue = [{q:u.q, r:u.r, mp:u.mpLeft}];
  const out = [];
  while (queue.length) {
    const cur = queue.shift();
    out.push(cur);
    for (const n of neighbors(cur.q, cur.r)) {
      if (!inMap(n.q, n.r)) continue;
      if (unitAt(n.q, n.r) && !(n.q === u.q && n.r === u.r)) continue;
      const t = mapData.get(hexKey(n.q, n.r)).terrain;
      if (t.cost >= 90) continue;
      let cost = t.cost + (enemyZOC(n.q, n.r, opposite(u.side)) ? 1 : 0);
      const left = cur.mp - cost;
      if (left < 0) continue;
      const k = hexKey(n.q, n.r);
      if (!best.has(k) || left > best.get(k)) {
        best.set(k, left);
        queue.push({ q:n.q, r:n.r, mp:left });
      }
    }
  }
  return out;
}

function supplyConnected(u) {
  const sourceQ = u.side === 'GER' ? 0 : 12;
  const visited = new Set([hexKey(u.q, u.r)]);
  const queue = [{ q:u.q, r:u.r }];
  while (queue.length) {
    const c = queue.shift();
    if (Math.abs(c.q - sourceQ) <= 1) return true;
    for (const n of neighbors(c.q, c.r)) {
      if (!inMap(n.q, n.r)) continue;
      const t = mapData.get(hexKey(n.q, n.r)).terrain;
      if (t.cost >= 90) continue;
      const enemy = unitAt(n.q, n.r);
      if (enemy && enemy.side !== u.side) continue;
      const k = hexKey(n.q, n.r);
      if (visited.has(k)) continue;
      visited.add(k);
      queue.push(n);
    }
  }
  return false;
}

function enemyZOC(q, r, enemySide) {
  return units.some(u => u.alive && u.side === enemySide && hexDist(u.q, u.r, q, r) === 1);
}

function enemiesAdjacent(u) {
  return neighbors(u.q, u.r).map(n => unitAt(n.q, n.r)).filter(v => v && v.side !== u.side && v.alive);
}

function weakest(arr) { return [...arr].sort((a,b) => a.hp - b.hp)[0]; }
function nearestUnfriendlyObjective(side, q, r) {
  return [...objectives].filter(o => o.owner !== side).sort((a,b) => hexDist(q,r,a.q,a.r)-hexDist(q,r,b.q,b.r))[0];
}

function unitAt(q, r) { return units.find(u => u.alive && u.q === q && u.r === r); }
function inMap(q, r) { return q>=0 && q<COLS && r>=0 && r<ROWS && mapData.has(hexKey(q,r)); }
function hexKey(q,r) { return `${q},${r}`; }
function opposite(s) { return s === 'GER' ? 'SOV' : 'GER'; }

function neighbors(q, r) {
  return [{q:q+1,r},{q:q+1,r:r-1},{q,r:r-1},{q:q-1,r},{q:q-1,r:r+1},{q,r:r+1}];
}

function hexToPixel(q, r) {
  return {
    x: originX + hexSize * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r),
    y: originY + hexSize * (1.5 * r)
  };
}

function pixelToHex(px, py) {
  const x = (px - originX) / hexSize;
  const y = (py - originY) / hexSize;
  const q = Math.sqrt(3)/3 * x - 1/3 * y;
  const r = 2/3 * y;
  return cubeRound(q, r);
}

function cubeRound(q, r) {
  let x = q, z = r, y = -x-z;
  let rx = Math.round(x), ry = Math.round(y), rz = Math.round(z);
  let dx = Math.abs(rx - x), dy = Math.abs(ry - y), dz = Math.abs(rz - z);
  if (dx > dy && dx > dz) rx = -ry-rz;
  else if (dy > dz) ry = -rx-rz;
  else rz = -rx-ry;
  return { q:rx, r:rz };
}

function hexShape(cx, cy) {
  beginShape();
  for (let i=0;i<6;i++) {
    const a = TWO_PI * (i + .5) / 6;
    vertex(cx + hexSize * cos(a), cy + hexSize * sin(a));
  }
  endShape(CLOSE);
}

function hexDist(q1,r1,q2,r2) {
  let x1=q1,z1=r1,y1=-x1-z1;
  let x2=q2,z2=r2,y2=-x2-z2;
  return max(abs(x1-x2), abs(y1-y2), abs(z1-z2));
}

function log(t) {
  logs.push(t);
  if (logs.length > 120) logs.shift();
}
</script>
</body>
</html>
